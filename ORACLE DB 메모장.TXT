기본 명령어

--      : 한 줄 주석
/* */   : 여러 줄 주석

SELECT : 조회
지정된 테이블에서 원하는 데이터를 선택해서 조회하는 SQL\

조회된 결과 행의 집합 == RESULT SET(결과 집합)

RESULT SET은 0행 이상 포함될 수 있다
--> 조건에 맞는 행이 없을 수도 있어서


[SELECT 작성법 1]
SELECT 컬럼, 컬럼, ...
FROM 테이블;

-> 테이블 모든 행에서 컬럼명이 일치하는 컬럼값 조회

모든행, 모든 컬럼 조회 : * ASTERISK 이용함
-> 
SELECT * FROM 테이블;

[컬럼 값 산술 연산]
컬럼 값 : 행과 열이 교차되는 테이블의 한 칸에 작성된 값

SELECT문 작성 시 컬럼명에 산술 연산을 직접 작성하면 
조회 결과에 연산 결과가 반영되어 조회된다!
    SELECT SALARY, SALARY + 1000000
    FROM EMPLOYEE

    -> SALARY 값과 + 100만 계산된 값 함께 조회됨
    -> SALARY에 100만이 더해진 결과가 반영되는 것이 아닌
       SALARY + 1000000 컬럼 하나 생성되는 것!

[시간 표현하기]
- SYSDATE
    - 현재시간 조회
    - 연 월 일 시 분 초
- SYSTIMESTAMP
    - 현재시간 조회
    - 연 월 일 시 분 초 밀리초 + 지역(한국: + 9:00)
- TO_DATE('문자열', '패턴') : '문자열'을 '패턴 형태로 해석해서 DATE 타입으로 변경'
- TO_DATE('2024-01-01', 'YYYY-MM-DD') --""아닌 '' 사용!

숫자 올림처리
CEIL(숫자) -> 괄호 안의 숫자 정수단위 올림처리
괄호 안에 TO_DATE 사용 가능

- 

날짜데이터 연산은 +, - 만 가능
+ 1               : 1일 추가
+ 1/24            : 1시간 추가
+ 1/24/60         : 1분 추가
+ 1/24/60/60      : 1초 추가
+ 1/24/60/60 * 10 : 10초 추가

날짜끼리 연산
1. 날짜 - 날짜 == 일단위 숫자로 나옴
    결과
    1 : 1일
    1.5 : 1일 12시간

[임시 테이블]
DUAL TABEL
DUAL(dummy tAbLe)
- 가짜테이블(임시테이블)
- 실존하는 테이블이 아님
- 테이블 데이터가 아닌 단순 데이터 조회 시 사용

[컬럼별 별칭 지정하기]
추출된 데이터 컬럼 한눈에 알아볼 수 있게 하기
    1. 컬럼명 AS 별칭   : 문자
    2. 컬럼명 AS "별칭" : 문자, 띄어쓰기포함 특수문자
    3. 컬럼명 별칭      : 문자
    4. 컬럼명 "별칭"    : 문자, 띄어쓰기포함 특수문자
++ "" : ""사이 글자를 그대로 인식함
++ '' : 문자열

++개발 언어별 "" 사용법

HTML, JS 	: STRING == ''
JAVJA    	: STRING != '' (CHAR)
DB(ORACLE) : "" 글자 그대로 인식. (TEXT)

[연결 연산자 ||]
- 오라클에서는 연산자를 기호로 안씀(단어 그대로 씀 AND, OR, NOT)
- ||는 문자열 이어쓰기(+로 연결 안됨!!)

SELECT EMP_ID || EMP_NAME 
FROM EMPLOYEE ;
--> 결과 : EMP_ID EMP_NAME 같이 나옴
           200선동일
           201송종기 ...

[컬럼명 자리에 리터럴 직접 작성]
SELECT EMP_NAME , SALARY, '원'
FROM EMPLOYEE ;
    결과 : 조회 결과(RESULT SET)의 모든 행에 
           컬럼명 자리에 작성한 리터럴 값이 추가된다!!

[DISTINCT]
조회 결고의 집합에서
지정된 컬럼의 값이 중복되는 경우 이를 한번만 표현
    사용처: 입력된 구분 값 종류 조회할 때
    SELECT DISTINCT DEPT_CODE 
    FROM EMPLOYEE;
    --> DEPT_CODE 종류별로 하나씩만 출력


/* ++ 절의 종류
 * 1. SELECT
 * 2. FROM + JOIN
 * 3. WHERE
 * 4. GROUP BY
 * 5. HAVING
 * 6. ORDER BY 
 * */

[WHERE 절]
테이블에서 조건을 충족하는 행 조회 시 사용
WHERE절에는 조건식(TRUE/FALSE)만 작성

비교연산자 : >,<,>=,<=, =, !=, <> (같지않다)
    특징 : 같지않다 뜻하는 연산자 2개(1=, <>)
           같다 뜻하는 연산자는 = 하나만 쓴다(==가 아니다!)

논리연산자 : AND OR NOT
    특징   : 문자 그대로 작성한다.

[SELECT 작성법2]

SELECT 컬럼1, 컬럼2, ...
FROM 테이블명
WHERE 조건식;

-> 지정된 테이블의 모든 행에서 컬럼명이 일치하는 컬럼 값 조회된

- 작동 방식 및 순서
1. FROM 절에 지정된 테이블에서
2. WHERE 절로 지정된 행을 추림
3. 추려진 행들을 SELECT 절로 조회된

[NULL 조회하기!!]
[빈칸 감지 함수]
NULL - ORACLE에서 NULL은 값이 아님.
저장된 값이 없음을 표현하는 의미
-> SELECT = NULL -> 값이 없는것이 아니라 
   값이 문자열 NULL 인 컬럼을 찾아오는 것으로 인식함!
-> 진짜 NULL(값이 없음)을 찾고 싶으면 빈칸을 감지하는 함수 사용
컬럼명 IS NULL : 컬럼 값이 존재하지 않다면 TRUE
컬럼명 IS NOT NULL : 컬럼 값이 존재한다면  FALSE

[논리연산 AND, OR]
다른 개발 언어의 AND 연산, OR 연산과 사용법 동일함
AND : 둘 다 참이어야 TRUE 반환 -> 및
OR : 둘 중 하나만 참이어도 TRUE 반환 -> 또는

[ BETWEEN ]
[1. BETWEEN A AND B]
- 컬럼의 값이 A 이상 B 이하면 TRUE
-> TEMP 값이 1000 이상, 2000 이하인 컬럼만 추리기
    WHERE TEMP >= 1000 AND TEMP <= 2000;
    WHTER TEMP BETWEEN 1000 AND 2000;

[2. NOT BETWEEN A AND B]
- 컬럼의 값이 A 이상 B 이하이면 FALSE
-> TEMP 값이 1000미만 또는 2000 초과인 컬럼 추리기
    WHERE TEMP < 1000 OR TEMP > 2000 
    WHERE TEMP NOT BETWEEN 1000 AND 2000

- BETWEEN 사용처
    게시판 하부의 페이지 조회
    특정한 범위 내의 값을 조회할 때 사용함

    + TO_DATE('날짜', '패턴') 이용하여
      날짜도 비교 가능함(날짜끼리)

[IN]
컬럼명 IN(값1, 값2, 값3, ...)
- 컬럼의 값이 ()안의 값과 일치하면 TRUE 반환

[NOT IN]
컬럼명 NOT IN(값1, 값2, 값3, ...)
- 컬럼의 값이 ()안의 값과 일치하면 FALSE 반환
    -> 컬럼의 값이 () 안의 값과 일치하지 않으면 FALSE

[LIKE]

비교하려는 값이 특정한 패턴을 만족시키면 TRUE 반환 연산자

- 작성법
WHERE 칼럼명 LIKE '패턴'

LIKE 패턴(와일드카드)의 종류
    1. '%' : 포함. 어떤 것이든 괜찮음. 없는 문자열도 포함시킴.
        '%A'  : A로 끝나는 문자열
        'A%'  : A로 시작되는 문자열
        '%A%' : 중간에 A가 포함된 문자열

    2. '_' : 글자 수
        'A_'  : A로 시작, 뒤에 아무거나 한 글자만 있는 문자열
        '__A' : A 앞에 아무거나 두 글자만 있는 문자열
    
 - 비교
 WHERE PHONE LIKE '010%'; -- %버전
 WHERE PHONE LIKE '010________'; -- _ 버전

 - 조합
 요구 : EMAIL의 아이디 (@ 앞의 글자)의 글자 수가 5글자인 사원조회
 WHERE EMAIL LIKE '_____@%'; -- _,와일드카드(%)같이 사용

- ESCAPE 문자
!!! : ESCAPE 문자는 임의로 지정 가능
요구 : 이메일의 아이디 중 '_' 앞 쪽 글자의 수가 3글자인 사원 조회
ESCAPE 안쓰면 구분 기준 _ 가 와일드카드로 인식됨
WHERE EMAIL LIKE '___._%' ESCAPE'.';
--> ESCAPE 문자는 아무거나 사용 가능. 지금은 .으로 사용

---------------------------------------------------
[ORDER BY 절]

    {설명}
    - SELECT문의 조회 결과(RESULT SET)를 정렬할 때 사용하는 구문 
    - SELECT 구분에서 제일 마지막에 해석됨
    - 작성법 및 해석 순서
        3. SELECT 컬럼명 "별칭"
        1. FROM 테이블명
        2. WHERE 조건식
        4. ORDER BY 
    해석 순서에 따라 "별칭"은 ORDER BY 절에서 사용 가능, WHERE절에서 사용 불가능

    {오름차순, 내림차순}
    - 오름차순 : ASC(ASCENDING). 기본값
    -> ORDER BY COLUMNAME ASC;

    - 내림차순 : DESC(DESCENDING)
    -> ORDER BY COLUMNAME DESC;

    {SELECT절에 사용한 구문 ORDER BY 절에서 사용하기}
    - 해석 순서에따라 후순위 해석절은 
      선순위 해석절에서 사용한 구문 재사용 가능
      -> WHERE절은 SELECT 절보다 선순위 해석, 
         SELECT절에서 사용한 구문 재사용 불가능
    - 1. 수식 사용 가능
        - SELECT절에서 사용한 수식 대입 가능 
        ->
        SELECT EMP_NAME, SALARY * 12 연봉
        FROM EMPLOYEE
        ORDER BY SALARY * 12 DESC;
    - 2. 별칭 사용 가능
        SELECT EMP_NAME, SALARY * 12 연봉
        FROM EMPLOYEE
        ORDER BY 연봉 DESC;

[NULLS FIRST/LAST]
- 일반적으로 ORDER BY절과 함께 사용
- NULL인 경우 제일 위에/마지막에 위치
- NULLS LAST가 기본값 : NULL은 항상 마지막에 온다.
    {NULLS FIRST}
    - SELECT EMP_NAME , PHONE 
      FROM EMPLOYEE
      ORDER BY PHONE DESC NULLS FIRST

[정렬 중첩]
- 먼저 작성된 정렬 기준을 깨지 않고 다음 작성된 정렬 기준 적용
- 정렬 기준이 여러개!!

    EX) 부서별로 오름차순 정렬 후, 급여 내림차순으로 조회
    -> 부서별로 오름차순 정렬
    -> 오름차순으로 정렬 된 부서 내에서 급여를 비교하여 내림차순으로 조회
    SELECT EMP_NAME, DEPT_CODE, SALARY
    FROM EMPLOYEE
    ORDER BY DEPT_CODE, SALARY DESC ;
    -- ASC : 오름차순. 기본값이므로 생략 가능



------ 단일행 함수와 그룹 함수 -----

함수 : 컬럼 값 | 지정된 값을 읽어 연산한 결과를 반환하는 것
단일행 함수 : N개의 행의 컬럼 값을 전달하여 N개의 결과가 반환
그룹 함수 : N개의 행의 컬럼 값을 전달하여 1개의 결과가 반환
            (그룹 수 만큼 결과를 반환)

함수 사용 가능한 절
    - SELECT
    - WHERE
    - ORDER BY
    - GROUP BY
    - HAVING

단일행 함수
    - 문자열 관련 함수
        1. LENGTH(문자열 | 컬럼명) : 문자열/컬럼명의 길이 반환
        2. INSTR(문자열|컬럼명, '찾을 문자열',시작위치,순번) 
            - 시작위치~지정된 순번째 찾은 문자열의 시작 위치 반환
            반환값은 INDEX가 아님. 몇번째에 위치해 있는지
        3. SUBSTR(문자열|컬럼명, 시작위치, 길이)
            - 문자열을 시작 위치부터 길이만큼 잘라내서 반환
            - 시작위치 : 1부터 시작함
            - 길이 미작성 : 시작 위치부터 끝까지 잘라내서 반환
        4. TRIM( [ [옵션]문자열|컬럼명 FROM] 문자열|컬럼명)
            - 주어진 문자열의 앞,뒤,양쪽에 존재하는 지정된 문자열 제거
            - 옵션에 작성된 내용에 따라 앞,위,양옆 제거 위치 정해짐
            - 옵션 : LEADING(앞), TRAILING(뒤), BOTH(양쪽. 기본값)
        5. REPLACE(문자열|컬럼명, 찾을문자열, 바꿀 문자열)
            - 찾을문자열을 바꿀문자열로 변경
        
    - 숫자 관련 함수
        1. MOD MODULO. 나머지
            MOD(숫자 | 컬럼명, 나눌 값) 
            -> 나머지 값 산출
        2. ABS 절댓값
            ABS(숫자 | 컬럼명)
            -> 절댓값 산출
        3. ROUND 반올림
            ROUND(숫자 | 컬럼명 , 소수점 위치)
            소수점 위치까지 반올림
            소수점 위치 지정 X : 정수 1의 자리까지 반올림
            소수점 위치 지정 O 
                양수 : 지정된 위치의 소수점 자리까지 표현
                    EX) ROUND	(123.456, 1),   -- 123.5
	                    ROUND	(123.456, 2),   -- 123.46
                음수 : 지정된 위치의 정수 자리까지 표현
                        ROUND (123.456, -1),  -- 120
                        ROUND (123.456, -2)   -- 100
        4. CEIL, FLOOR 올림, 내림
            CEIL|FLOOR (숫자 | 컬럼명)
            정수 단위로 올림, 내림
        5. TRUNC 버림
            TRUNC(숫자 | 컬럼명 , 소수점 위치) : 버림
            소수점 위치 미작성 : 기본(정수단위)
            소수점 위치는 정수 양수로 표현 가능
            소수점 위치 양수 : 1, 10, 100 의 자리 수로 늘어남(기준점 왼쪽으로 이동)
            소수점 위치 음수 : 0.1, 0.01, .. (소수점 오른쪽으로 이동)

    - 날짜 관련 함수
        1. SYSDATE : 현재시간(시, 분, 초) 
        2. SYSTIMESTAMP : 현재시간(시, 분, 초, 밀리초, 기준시와의 시차)
        3. MONTH_BETWEEN(날짜, 날짜)
        4. ADD_MONTH(날짜, 숫자)
        5. LAST_DAY(날짜)
        6. EXTRACT ( YEAR | MONTH | DAY FROM 날짜)

    - 형변환 함수
        1. 문자열(CHAR, BARCHAR2) <-> 숫자(NUMBER)
        2. 문자열(CHAR, VARCHAR2) <-> 날짜(DATE)
        3. 숫자 --> 날짜
        4. 날짜는 숫자가 될 수 없음
        5. 날짜 -> 문자열 -> 숫자

        - 문자열로 변환 : TO_CHAR(날짜 | 숫자, '포맷') : 문자열로 변환
            숫자 -> 문자열
            포맷
            1. 9 : 숫자 한 칸을 의미, 오른쪽 정렬
            2. 0 : 숫자 한 칸 의미, 오른쪽 정렬, 빈 칸에 0 추가
            3. L : 현재 시스템이나 DB에 설정된 나라의 화폐 기호
            4. , : 숫자의 자릿수 구분.
        
        - 날짜 -> 문자열
            YY    : 짧은 년도 표현
            YYYY  : 긴 년도 표현
            RR    : 년도(짧게) 24
            RRRR  : 년도(길게) 2024
             Y, R의 차이점 
              연도가 두 자리만 작성되어 있는 경우
              50 미만 : Y,R 둘 다 누락된 연도 앞 부분을 현재 세기로 인식, 2000 추가
              50 이상 : Y : 현재 세기(2000년대 추가)
                        R : 이전 세기(1900년대 추가)
            MM    : 월
            DD    : 일
            HH    : 시간(12시간)
            HH24  : 시간(24시간)
            MI    : 분
            SS    : 초
            DAY   : 요일(전체) 월요일, MONDAY
            DY    : 요일(짧게) 월, MON          
        
        - 문자열 또는 숫자를 날짜 형식으로 변환
        --> TO_DATE

        - NULL 처리 연산
            IS NULL
            IS NOT NULL
            NVL(컬럼명, 컬럼 값이 NULL일 경우 변경할 값)
                -> 지정된 컬럼 값이  NULL일 경우 변경
            NVL2(컬럼명, NULL이 아닌 경우 변경할 값, NULL인 경우 변경할 값)
        
        - 선택 함수 DECODE, CASE
          여러 경우에 따라 알맞은 결과를 선택하는 함수
          나누어떨어지는 값을 구할 때 사용함
          IF, SWITCH문과 비슷함
          -> DECODE(컬럼명 | 계산식, 조건1, 결과1, 조건2, 결과2.. ,만족하는 경우 없을 시 결과)
             계산식의 값이 일치하는 조건이 있으면 해당 조건 오른쪽에 작성된 결과가 반환됨
             
             EX) DECODE( SUBSTR(EMP_NO, 8, 1 ), '1', '남자', '2', '여자') AS 성별

        - 선택 함수 CASE WHEN THEN ELSE END
          계산식|컬럼 값을 범위로 지정할 수 있다
          -> CASE
                WHEN 조건1 THEN 결과1
                WHEN 조건2 THEN 결과2
                WHEN 조건1 THEN 결과3
                ELSE 결과
            END
            
그룹함수
    - SUM(컬럼명) : 그룹의 합계를 반환
    - AVG(숫자만 기록된 컬럼명) : 그룹의 평균 반환
    - MAX(컬럼명) : 최댓값
    - MIN(컬럼명) : 최솟값
    - COUNT(* | 컬럼명) : 조회된 행의 개수를 반환
      COUNT(*) : 조회된 모든 행의 개수를 반환
      COUNT(컬럼명) : 지정된 컬럼 값이 NULL이 아닌 행의 개수를 반환
      -> NULL인 행 미포함
      COUNT(DISTINCT 컬럼명) : 지정된 컬럼에서 중복 값을 제외한 행의 개수를 반환
      -> A A VA C D D D E    : 5개 (중복은 한번만 카운트) 

------- GROUP BY HAVING -----------------

읽기 전..
SELECT문 해석 순서

5. SELECT 컬럼명 별칭, 계산식, 함수식
1. FROM 테이블명
2. WHERE 
3. GROUP BY 그룹을 묶을 컬럼명
4. HAVING 그룹함수식, 비교연산자, 비굣값
6. ORDER BY 컬럼명 | 별칭 | 컬럼순번 정렬 방식


GROUP BY 절 
 - 같은 값들이 여러 개 기록된 컬럼을 가지고 같은 값들을 하나의 그룹으로 묶음
 - 여러 개의 값을 묶어서 하나로 처리할 목적으로 사용함
 - 그룹으로 묶은 값에 대해 SELECT 절에서 그룹함수를 사용함
 - 그룹함수는 단 하나의 결과 값만 산출. 그룹이 여러개면 오류 발생
 - 여러개의 결과 값을 산출하려면 그룹함수가 적용된 그룹의 기준을 ORDER BY절에 기술하여 사용

WHERE + GROUP BY
 - WHERE 절은 각 컬럼 값에 대한 조건
 - WHERE절이 먼저 해석됨

여러 컬럼을 묶어서 그룹으로 지정 가능함
 - SELECT절에 GROUP BY절 사용할 경우
   SELECT절에 명시한 컬럼을 조회하려면 컬럼 중 그룹함수가 적용되지 않은 컬럼을
   모두 GROUP BY 절에 작성해야함.
   -> GROUP BY절로 묶인 컬럼은 SELECT절에서 작성되어야한다.

HAVING
 - 그룹 함수로 구해 올 그룹에 대한 조건을 설정할 때 사용. 그룹에 대한 조건1
 - HAVING 컬럼명 | 함수식, 비교연산자, 비교값
 - WHERE절 : 지정된 테이블에서 어떤 행만을 조회 결과로 삼을 것인지 조건을 지정하는 구문
             테이블 내에서 특정 행만 뽑아서 쓰겠다는 조건문

----------- GROUP BY 함수 : 집계함수 ROLLUP, CUBE-------------------------------
ROLLUP, CUBE
그룹 별 산출한 결과 값의 집계를 계산하는 함수
GROUP BY 절에만 작성하는 함수

ROLL UP 함수
 - 그룹별로 중간 집계 처리하는 함수
 - 그룹별로 묶여진 값에 대한 중간집계, 총 집계를 계산하여 자동으로 추가하는 함수
 - 인자로 전달받은 그룹 중에서 가장 먼저 지정한 그룹별 합계와 총합계를 구하는 함수

CUBE 함수 : 그룹별 산출한 결과를 집계하는 함수
 - 그룹으로 지정된 모든 그룹에 대한 집계와 총 합계를 구하는 함수


----------- 집합 연산 SET OPERATION -----------

여러개의 SELECT 결과물을 하나의 쿼리로 만드는 연산자
여러가지의 조건이 있을 때 그에 해당하는 여러개의 결과값을 결합시키고 싶을때 사용
집합연산에 사용되는 SELECT문은 SELECT절이 동일해야함

종류 
 - UNION       : 합집합(=OR, 중복 제거)
 - INTERSECT   : 교집합(= AND)
 - UNION ALL   : 합집합 + 교집합(중복 미제거)
 - MINUS       : 차집합



------------------ JOIN ----------------------------
하나 이상의 테이블에서 테이터를 조회하기 위해 사용
수행 결과는 하나의 RESULT SET으로 나옴

JOIN이란 무엇인가..
관계형 데이터베이스에서 SQL을 이용해 테이블간 관계를 맺는 방법.
관계형 데이터베이스는 최소한의 데이터를 테이블에 담고 있어 원하는 정보를
테이블에서 조회하려면 한 개 이상의 테이블에서 데이터를 읽어와야하는 경우 많음.
이때, 테이블간 관계를 맺기 위한 연결고리 역할이 필요한데
두 테이블에서 같은 데이터를 저장하는 컬럼이 연결고리가 된다.

JOIN은 단순히 테이블 두개를 붙이는 것이 아닌
기준 삼은 테이블의 한 컬럼을 지정해
다른 테이블의 한 컬럼과 같은 행을 찾아 
기준 테이블 옆에 한 행씩 붙여 나가는 것

ANSI 방식, ORACLE 방식 있는데 ANSI 방식으로 학습하는 것이 좋음.
ORACLE 방식은 알아만 두라



1. 내부 조인(INNER JOIN == 등가조인(EQUAL JOIN))

	- 연결에 사용할 두 컬럼명이 다른 경우 --> JOIN ON 사용
		SELECT / FROM 테이블1 / JOIN 테이블2 ON (테이블1의 컬럼 = 테이블2의 컬럼)
		-> 괄호 안의 컬럼명 순서는 바뀌어도 상관 없음

	- 연결에 사용할 두 컬럼명이 같은 경우 -> JOIN USING 사용
		- 사용법 : SELECT / FROM 테이블1 / JOIN 테이블2 USING(두 테이블의 동일한 컬럼명)
			-> 중복되는 컬럼이 포개지듯 합쳐짐 -> 컬럼 수 하나 줄어듦

		- 다른 테이블의 이름이 같은 컬럼이라 어느 테이블 소속인지 헷갈림
			1. 테이블명.컬럼명 으로 컬럼이 속한 테이블 지정하기
			2. FROM절에서 테이블 지정과 동시에 별칭 정하기 가능
				 -> 정한 별칭을 테이블명 대신 사용하여 지정하기
	
2. 외부 조인 (OUTER JOIN)
	두 테이블의 지정하는 컬럼값이 일치하지 않는 행도 조인에 포함 시킴
	반드시 OUTER JOIN임을 명시해야 함

	1) LEFT (OUTER) JOIN
		 합치기에 사용 한 두 테이블 중 왼편에 기술된 테이블의 컬럼 수를 기준으로 JOIN

	2) RIGHT(OUTER)JOIN
		 오른편에 기술된 테이블의 컬럼 수를 기준으로 JOIN
	
	3) FULL(OUTER)JOIN
		 합치기에 사용한 두 테이블이 가진 모든 행을 결과에 포함

3. 교차조인(CROSS JOIN == CARTESIAN PRODUCT)
	 조인되는 테이블의 각 행들이 모두 매핑된 데이터가 검색되는 방법(곱집합)
	 모든 경우의 수를 보고싶을때 제외하곤 작성하는 경우 거의 없음
	 6. 자연조인 실패 결과로 교차 조인 결과 출력됨..

4. 비등가 조인(NON EQUAL JOIN)
	 등호를 사용하지 않는 조인
	 지정한 컬럼 값이 일치하는 경우가 아닌, 값의 범위에 포함되는 행들을 연결하는 방식


5. 자체조인(SELF JOIN)
	 같은 테이블을 조인, 자기 자신과 조인을 맺음

6. 자연조인(NATURAL JOIN)
	 동일한 타입과 이름을 가진 컬럼이 있는 테이블간의 조인을 간단히 표현하는 방법
	 두 테이블간의 동일한 이름, 타입을 가진 컬럼 두개 필요
	 -->없을 경우 교차조인됨

7. 다중조인
	 N개의 테이블을 조회할 때 사용
	 FROM 테이블1 T1 
	 JOIN 테이블2 T2 ON (T1.컬럼 = T2.컬럼) 
	 JOIN 테이블3 T3 ON (T2.컬럼 = T3.컬럼)

	 JOIN ON을 여러번 사용하는 방법으로 사용.